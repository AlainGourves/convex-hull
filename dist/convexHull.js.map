{"mappings":"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","sources":["lib/convexHull.js","lib/point.js"],"sourcesContent":["import Point from \"./point.js\";\n\n/**\n * Represents a Convex Hull generated from a set of points using the Graham's scan algorithm.\n */\nclass ConvexHull {\n    /**\n     * @constructor\n     * @param {Point[]} points - The array of points for which to find the convex hull.\n     */\n    constructor(points) {\n        this.p0; // starting point\n        this.points = points;\n\n        if (this.points.length < 3) {\n            throw new Error(\"We need at least 3 points to compute a hull!\");\n        }\n    }\n\n    /**\n     * Finds and returns the starting point for the convex hull computation.\n     * Lowest leftmost point (i.e. max y)\n     * @returns {Point} The starting point for convex hull computation.\n     */\n    getStartPoint() {\n        let maxY = -1;\n        let maxIdx = -1;\n        this.points.forEach((pt, idx) => {\n            if (pt.y > maxY || (pt.y === maxY && pt.x < this.points[maxIdx])) {\n                // if there's a tie, takes the left-most point\n                maxY = pt.y;\n                maxIdx = idx;\n            }\n        });\n        // place found point at the start of the array (by destructuring)\n        [this.points[0], this.points[maxIdx]] = [this.points[maxIdx], this.points[0]]\n        return this.points[0];\n    }\n\n    /**\n     * Computes the orientation of three points (clockwise, counterclockwise, or collinear).\n     *\n     * @param {Point} A - The first point.\n     * @param {Point} B - The second point.\n     * @param {Point} C - The third point.\n     * @returns {number} The orientation: 0 for collinear, 1 for clockwise, -1 for counterclockwise.\n     */\n    getOrientation(A, B, C) {\n        // Compute the determinant of vectors AB & AC\n        // note that it's the opposite of the \"normal\" computation, as the y-coordinate increases downwards on the screen\n        const det = (B.x - A.x) * (C.y - A.y) - (B.y - A.y) * (C.x - A.x);\n        if (det === 0) {\n            // points are collinears\n            return 0;\n        } else if (det > 0) {\n            // clockwise\n            return 1;\n        } else {\n            // counter clockwise\n            return -1;\n        }\n    }\n\n    /**\n     * Cleans the array of points by keeping only the farthest points in case of collinearity.\n     *\n     * @returns {Point[]} The cleaned array of points.\n     */\n    clean() {\n        let temp = [this.points[0]];\n        for (let i = 1; i <= this.points.length - 2; i++) {\n            // get orientation between p0-p[i] and p0-p[i+1]\n            let orient = this.getOrientation(this.p0, this.points[i], this.points[i + 1]);\n            if (orient === 0) {\n                // => points are collinear, only keep the farthest\n                if (this.p0.sqDist(this.points[i]) > this.p0.sqDist(this.points[i + 1])) {\n                    temp.push(this.points[i]);\n                }\n            } else {\n                temp.push(this.points[i])\n            }\n        }\n        temp.push(this.points[this.points.length - 1]);\n        return temp;\n    }\n\n    /**\n     * Computes the convex hull of the set of points using the Graham's scan algorithm.\n     *\n     * @returns {Point[]} The array of points representing the convex hull.\n     */\n    getPoints() {\n        if (this.points.length === 3) {\n            // triangle, which is a convex hull !\n            return this.points;\n        }\n        // Find the point with the lowest y-coordinate.\n        // If the lowest y-coordinate exists in more than one point in the set, the point with the lowest x-coordinate out of the candidates should be chosen.\n        this.p0 = this.getStartPoint();\n\n        // sort the array by polar angle in CCW order, relative to point p0\n        this.points.sort((p1, p2) => {\n            const orient = this.getOrientation(this.p0, p1, p2);\n            if (orient === 0) {\n                if (this.p0.sqDist(p2) >= this.p0.sqDist(p1)) {\n                    return -1;\n                } else {\n                    return 1;\n                }\n            } else {\n                return orient;\n            }\n        });\n\n        // clean the array : if two or more points have the same angle, then only keep the point farthest from p0\n        this.points = this.clean();\n\n        // We need at least 3 points\n        if (this.points.length < 3) {\n            throw new Error(\"We need at least 3 distinct points to compute a hull!\");\n        };\n\n        // always look at 3 succesive points in the stack\n        let stack = [this.p0, this.points[1], this.points[2]];\n        // if the 3 points make a CW turn (getOrientation returns 1), remove the middle point\n        for (let i = 3; i < this.points.length; i++) {\n            while (true) {\n                if (stack.length < 2) break;\n                if (this.getOrientation(stack[stack.length - 2], stack[stack.length - 1], this.points[i]) !== 1) break;\n                stack.pop();\n            }\n            stack.push(this.points[i]);\n        }\n        return stack;\n    }\n}\n\nexport default ConvexHull;","/**\n * Represents a 2D point with x and y coordinates.\n */\nclass Point {\n    /**\n     * @constructor\n     * @param {number} x - The x-coordinate of the point.\n     * @param {number} y - The y-coordinate of the point.\n     */\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    /**\n     * Calculates the square distance to another point.\n     *\n     * @param {Point} other - The other point to calculate the distance to.\n     * @returns {number} The square distance between this point and the other point.\n     */\n    sqDist(other) {\n        const dx = other.x - this.x;\n        const dy = other.y - this.y;\n        return dx * dx + dy * dy;\n    }\n\n    /**\n     * Calculates the Euclidean distance to another point.\n     *\n     * @param {Point} other - The other point to calculate the distance to.\n     * @returns {number} The Euclidean distance between this point and the other point.\n     */\n    dist(other) {\n        return Math.sqrt(this.sqDist(other));\n    }\n}\n\nexport default Point;\n"],"names":[],"version":3,"file":"convexHull.js.map"}